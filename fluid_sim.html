<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
	<title>Euler Fluid</title>
	<style>
		body {
			font-family: verdana;
			font-size: 15px;
		}

		.button {
			background-color: #606060;
			border: none;
			color: white;
			padding: 10px 10px;
			font-size: 16px;
			margin: 4px 2px;
			cursor: pointer;
		}

		.slider {
			-webkit-appearance: none;
			width: 80px;
			height: 6px;
			border-radius: 5px;
			background: #d3d3d3;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
		}
	</style>
</head>

<body>

	<button class="button" onclick="setupScene(1)">Wind Tunnel</button>
	<button class="button" onclick="setupScene(3)">Hires Tunnel</button>
	<button class="button" onclick="setupScene(0)">Tank</button>
	<button class="button" onclick="setupScene(2)">Paint</button>
	<input type="checkbox" id="streamButton" onclick="scene.showStreamlines = !scene.showStreamlines">Streamlines
	<input type="checkbox" id="velocityButton" onclick="scene.showVelocities = !scene.showVelocities">Velocities
	<input type="checkbox" name="field" id="pressureButton" onclick="scene.showPressure = !scene.showPressure;">
	Pressure
	<input type="checkbox" name="field" id="smokeButton" onclick="scene.showSmoke = !scene.showSmoke;" checked>Smoke
	<input type="checkbox" id="overrelaxButton" onclick="scene.overRelaxation = scene.overRelaxation == 1.0 ? 1.9 : 1.0"
		checked>Overrelax
	<br>
	<canvas id="myCanvas" style="border:2px solid"></canvas>


	<script>
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// CANVAS SETUP - Initialize drawing surface
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		var canvas = document.getElementById("myCanvas");
		var c = canvas.getContext("2d"); // Get 2D drawing context
		canvas.width = window.innerWidth - 20;  // Set canvas width to almost full window
		canvas.height = window.innerHeight - 100; // Leave space for buttons

		canvas.focus(); // Allow keyboard input

		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// SIMULATION COORDINATE SYSTEM
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		var simHeight = 1.1; // Simulation world height (in meters)
		var cScale = canvas.height / simHeight; // Pixels per meter conversion factor
		var simWidth = canvas.width / cScale; // Simulation world width (in meters)

		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// FIELD TYPE CONSTANTS - Identify which data array to access
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		var U_FIELD = 0; // Horizontal velocity field
		var V_FIELD = 1; // Vertical velocity field
		var S_FIELD = 2; // Smoke/marker field

		var cnt = 0; // Counter for debugging/tracking

		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// COORDINATE CONVERSION FUNCTIONS
		// Convert between simulation coordinates and canvas pixel coordinates
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		
		// Convert simulation X coordinate to canvas pixel X
		function cX(x) {
			return x * cScale;
		}

		// Convert simulation Y coordinate to canvas pixel Y
		// (Flips Y-axis because canvas Y increases downward but simulation Y increases upward)
		function cY(y) {
			return canvas.height - y * cScale;
		}

		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// FLUID SIMULATION CLASS - The heart of the physics engine
		// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// ----------------- start of simulator ------------------------------

		class Fluid {
			/**
			 * Creates a new fluid simulation grid
			 * @param {number} density - Fluid density (kg/mÂ³), typically 1000 for water
			 * @param {number} numX - Number of grid cells horizontally
			 * @param {number} numY - Number of grid cells vertically
			 * @param {number} h - Cell size (grid spacing in meters)
			 */
			constructor(density, numX, numY, h) {
				this.density = density; // Fluid density (affects pressure calculations)
				this.numX = numX + 2; // Add 2 boundary cells (left + right)
				this.numY = numY + 2; // Add 2 boundary cells (top + bottom)
				this.h = h; // Grid cell size (spacing between cells)
				this.numCells = this.numX * this.numY; // Total number of cells in grid
				
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				// VELOCITY FIELDS - Store fluid motion
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				this.u = new Float32Array(this.numCells); // x-velocity (horizontal component)
				this.v = new Float32Array(this.numCells); // y-velocity (vertical component)
				this.newU = new Float32Array(this.numCells); // Temporary buffer for advection
				this.newV = new Float32Array(this.numCells); // Temporary buffer for advection
				
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				// SCALAR FIELDS - Store pressure, solid/fluid markers, and smoke
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				this.p = new Float32Array(this.numCells); // pressure field
				this.s = new Float32Array(this.numCells); // solid field (0.0=solid/wall, 1.0=fluid)
				this.m = new Float32Array(this.numCells); // marker field (smoke/dye density)
				this.newM = new Float32Array(this.numCells); // Temporary buffer for smoke advection
				this.m.fill(1.0); // initialize as fluid (all cells start with smoke)
				var num = numX * numY; // number of fluid cells (without boundary)

			}

			/**
			 * STEP 1: Apply gravity to vertical velocity
			 * Simulates gravitational acceleration pulling fluid downward
			 * @param {number} dt - Time step (seconds)
			 * @param {number} gravity - Gravitational acceleration (m/sÂ²), typically -9.81
			 */
			integrate(dt, gravity) {
				var n = this.numY; // Store numY for efficient array indexing
				// Loop through all interior cells (skip boundaries)
				for (var i = 1; i < this.numX; i++) {
					for (var j = 1; j < this.numY - 1; j++) {
						// Only apply gravity if current cell AND cell below are both fluid (not solid)
						if (this.s[i * n + j] != 0.0 && this.s[i * n + j - 1] != 0.0) { // if there is smoke here and below
							this.v[i * n + j] += gravity * dt; // apply gravity (v += g * dt)
						}
					}
				}
			}

			/**
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * STEP 2: SOLVE INCOMPRESSIBILITY - The Core Physics Engine!
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * Enforce incompressibility of the velocity field by solving the pressure Poisson equation
			 * and projecting the velocity to be divergence-free.
			 *
			 * This function performs an iterative pressure solve (e.g., Gaussâ€“Seidel/Jacobi style)
			 * for the specified number of iterations to approximate the pressure field that removes
			 * divergence from the velocity field. After (or during) the solve it subtracts the pressure
			 * gradient (appropriately scaled by dt and grid spacing) from the velocity to produce a
			 * divergence-free velocity field. Boundary conditions for pressure and velocity are applied
			 * as part of the procedure. The operation updates the simulator's internal velocity and
			 * pressure arrays in-place to enforce mass conservation.
			 *
			 * KEY CONCEPT: Real fluids can't be compressed - this ensures mass conservation
			 * 
			 * @param {number} numIters - Number of iterations to run the linear solver. More iterations
			 *                             yield a more accurate projection at higher computational cost.
			 * @param {number} dt       - Simulation time step (seconds). Used to scale pressure-gradient
			 *                             corrections when projecting velocities and can affect solver scaling.
			 * @returns {void}          - No return value; modifies simulation state (pressure/velocity) in-place.
			 */
			solveIncompressibility(numIters, dt) {

				var n = this.numY; // Store for efficient indexing
				// cp = (rho * cellVolume) / dt, used to scale the discrete divergence into the pressure RHS
				var cp = this.density * this.h / dt; // Pressure scaling factor

				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				// ITERATIVE SOLVER - Repeat to converge to correct pressure field
				// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				for (var iter = 0; iter < numIters; iter++) {
					// Loop through interior cells only (boundaries handled separately)
					for (var i = 1; i < this.numX - 1; i++) { // iterating till the 2nd last cell because of boundary conditions
						for (var j = 1; j < this.numY - 1; j++) {

							// Skip solid cells (walls/obstacles) - only process fluid cells
							if (this.s[i * n + j] == 0.0)
								continue; // skip if not fluid cell


							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// CHECK NEIGHBOR CELLS - Count how many are fluid
							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// ğŸ”‘ The Solution: i*n + j
							// This formula converts 2D coordinates (i, j) into a 1D array index.

							// What the Variables Mean:
							// i = row number (which row down)
							// j = column number (which column across)
							// n = this.numY = number of rows (grid height)
							// ğŸ“ The Formula Breakdown:
							// How It Works:
							// i*n = Skip past all the complete rows before row i
							// + j = Move j positions to the right in the current row

							var s = this.s[i * n + j]; // Current cell (will be overwritten below)

							var sx0 = this.s[(i - 1) * n + j]; // left neighbor (0=solid, 1=fluid)
							var sx1 = this.s[(i + 1) * n + j]; // right neighbor
							var sy0 = this.s[i * n + (j - 1)]; // down neighbor (bottom)
							var sy1 = this.s[i * n + (j + 1)]; // up neighbor (top)
							var s = sx0 + sx1 + sy0 + sy1; // overwrite s to be sum of neighbors (count fluid neighbors)
							if (s == 0.0)
								continue; // skip if no fluid neighbors (completely surrounded by walls)

							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// CALCULATE DIVERGENCE - Measure compression/expansion
							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// Divergence = (flow OUT) - (flow IN)
							// Positive divergence = too much fluid coming in (compressed)
							// Negative divergence = too much fluid going out (stretched)
							var div = this.u[(i + 1) * n + j] - this.u[i * n + j] +
								this.v[i * n + (j + 1)] - this.v[i * n + j];  // fluid coming in minus fluid going out on all sides

							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// COMPUTE PRESSURE CORRECTION
							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							var p = -div / s;  // pressure is scaled negative divergence (negative to push fluid OUT of compressed areas)

							// Apply over-relaxation to speed up convergence
							p *= scene.overRelaxation; // over-relaxation factor (typically 1.9)
							this.p[i * n + j] += p * cp; // accumulate pressure (cp scales to physical units)


							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// UPDATE VELOCITIES - Apply pressure gradient
							// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
							// High pressure pushes fluid OUTWARD in all directions
							// update velocities based on pressure gradient
							this.u[i * n + j] -= sx0 * p;  // Reduce flow INTO cell from LEFT
							this.u[(i + 1) * n + j] += sx1 * p; // Increase flow OUT of cell to RIGHT
							this.v[i * n + j] -= sy0 * p; // Reduce flow INTO cell from BELOW
							this.v[i * n + (j + 1)] += sy1 * p; // Increase flow OUT of cell to ABOVE
						}
					}
				}
			}
			
			/**
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * STEP 3: EXTRAPOLATE VELOCITIES TO BOUNDARIES
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * Copies velocity values from inside the grid to the boundary edges.
			 * This prevents undefined/zero velocities at boundaries which would cause artifacts.
			 *
			 * Before:          After extrapolate:
			 * [?][?][?][?]  â†’  [5][5][7][3]
			 * [5][7][3][2]     [5][7][3][2]
			 * [4][6][8][1]     [4][6][8][1]
			 */
			extrapolate(){
				var n = this.numY;
			
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// Copy horizontal velocities (u) to top and bottom edges
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				for (var i = 0; i < this.numX; i++){
					// Bottom edge: copy from row 1 to row 0
					this.u[i*n + 0] = this.u[i*n + 1];
					// Top edge: copy from second-to-last row to last row
					this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2];
				}

				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// Copy vertical velocities (v) to left and right edges
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				for(var j = 0 ; j < this.numY; j++){
					// Left edge: copy from column 1 to column 0
					this.v[0*n + j] = this.v[1*n + j]; 
					// Right edge: copy from second-to-last to last column
					this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j]; 
				}
			}

			/**
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * BILINEAR INTERPOLATION - Get smooth values between grid points
			 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			 * Gets a smooth value at ANY position (not just grid corners) by blending nearby values.
			 * Grid points:     What if we want value HERE? â˜…
			 * [10]----[20]     
			 * |       |      			 [10]----[20]
			 * |       |        		  |   â˜…   |
			 * [30]----[40]             [30]----[40]
			 * 
			 * This uses bilinear interpolation - like mixing 4 paint colors based on distance
			 * 
			 * @param {number} x - X position in simulation coordinates
			 * @param {number} y - Y position in simulation coordinates
			 * @param {number} field - Which field to sample (U_FIELD, V_FIELD, or S_FIELD)
			 * @returns {number} - Interpolated value at position (x, y)
			 */
			sampleField(x, y, field){
				var n = this.numY;
				var h = this.h; // Cell size
				var h1 = 1.0 / h; // inverse cell size (for efficient division)
				var h2 = 0.5 * h; // half cell size (for staggered grid offset)

				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// 1. Clamp position to grid bounds (prevent out-of-bounds access)
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				x = Math.max(Math.min(x, this.numX * h ), h); 
				y = Math.max(Math.min(y, this.numY * h ), h);


				var dx = 0.0; // X offset for staggered grid
				var dy = 0.0; // Y offset for staggered grid

				var f; // Pointer to the array we'll sample from
				
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// 2. Choose which array to sample (different fields stored at different locations)
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				switch (field){
						case U_FIELD: f = this.u; dy = h2; break;  // Horizontal velocity (offset vertically)
						case V_FIELD: f = this.v; dx = h2; break;  // Vertical velocity (offset horizontally)
						case S_FIELD: f = this.m; dx = h2; dy = h2; break; // Smoke (offset both directions - cell center)
				}

				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// 3. Find the 4 surrounding grid cells
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// Example: if x=2.7, then x0=2 and x1=3
				var x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 1); // Left cell index
				var x1 = Math.min(x0 + 1, this.numX - 1); // Right cell index
				
				
				var y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 1); // Bottom cell index
				var y1 = Math.min(y0 + 1, this.numY - 1); // Top cell index
				
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// 4. Calculate blend weights (how close to each corner?)
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

				var tx = ((x - dx) - x0*h) * h1;  // How far right (0 to 1)
				var ty = ((y - dy) - y0*h) * h1;  // How far up (0 to 1)

				var sx = 1.0 - tx;  // How far left (1 - right weight)
				var sy = 1.0 - ty;  // How far down (1 - up weight)

				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				// 5. Blend the 4 corner values using weighted average
				// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				var val = 	sx*sy * f[x0*n + y0] +  // Bottom-left corner weight
							tx*sy * f[x1*n + y0] +  // Bottom-right corner weight
							tx*ty * f[x1*n + y1] +  // Top-right corner weight
							sx*ty * f[x0*n + y1];   // Top-left corner weight

				return val; // Return smoothly interpolated value
			}

			/**
			 * Calculate average horizontal velocity (u) at cell center
			 * Averages the 4 surrounding u values (stored on cell edges)
			 * 
			 *     u[i,j]   u[i+1,j]
			 *        |       |
			 *        â”œâ”€â”€â”€â˜…â”€â”€â”€â”¤    â˜… = cell center (i,j)
			 *        |       |
			 *   u[i,j-1]  u[i+1,j-1]
			 * 
			 * @param {number} i - Grid column index
			 * @param {number} j - Grid row index
			 * @returns {number} - Average horizontal velocity at cell center
			 */
			avgU (i,j){
				var n = this.numY;
				// Average 4 u-values around the cell center
				var u = (this.u[i*n + j -1] + this.u[i*n + j] + 
						this.u[(i+1)*n + j -1] + this.u[(i+1) *n + j]	) * 0.25;
				return u;
			}

			/**
			 * Calculate average vertical velocity (v) at cell center
			 * Averages the 4 surrounding v values (stored on cell edges)
			 * 
			 *        v[i,j+1]
			 *            |
			 *    v[i-1,j] â˜… v[i,j]    â˜… = cell center (i,j)
			 *            |
			 *        v[i-1,j+1]
			 * 
			 * @param {number} i - Grid column index
			 * @param {number} j - Grid row index
			 * @returns {number} - Average vertical velocity at cell center
			 */
			avgV(i, j) {
			var n = this.numY;
			// Average 4 v-values around the cell center
			var v = (this.v[(i-1)*n + j] + this.v[i*n + j] +
				this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
			return v;
		}
		}